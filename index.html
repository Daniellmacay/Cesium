<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>GIS for Networks</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html, body, #cesiumContainer {
      margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
    }
    #controls {
      position: absolute;
      top: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 8px;
      font-family: sans-serif; font-size: 14px;
    }
    input[type="file"], select, input[type="range"] {
      display: block;
      margin-bottom: 5px;
    }
    #legend {
      position: absolute;
      bottom: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 8px;
      font-family: sans-serif; font-size: 14px;
      display: flex; flex-direction: column;
    }
    .legend-item {
      display: flex; align-items: center; margin-bottom: 5px;
    }
    .legend-color {
      width: 20px; height: 20px; border-radius: 50%; margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label>Cargar nodos CSV:</label>
    <input type="file" id="nodesFile" accept=".csv">
    <label>Columna para colorear:</label>
    <select id="colorColumnSelect"></select>
    <label>Filtrar por valor absoluto (<span id="filterValueDisplay">0</span>):</label>
    <input type="range" id="valueFilterSlider" min="0" max="1" step="0.00001">
    <label>Cargar aristas CSV:</label>
    <input type="file" id="edgesFile" accept=".csv">
    <label>Cargar GeoJSON:</label>
    <input type="file" id="geojsonFile" accept=".geojson,.json" multiple>
  </div>

  <div id="legend">
    <div class="legend-item">
      <div class="legend-color" style="background-color: #0000ff;"></div>
      <span>Frío</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #ffffff;"></div>
      <span>Neutral</span>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #ff0000;"></div>
      <span>Caliente</span>
    </div>
  </div>

  <div id="cesiumContainer"></div>

  <div id="tooltip" style="
    position: absolute;
    display: none;
    pointer-events: none;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 6px 10px;
    border-radius: 5px;
    font-size: 13px;
    font-family: sans-serif;
    z-index: 10000;"></div>

  <script>
    const viewer = new Cesium.Viewer("cesiumContainer", {
      terrainProvider: new Cesium.EllipsoidTerrainProvider(),
      imageryProvider: false,
      baseLayerPicker: false
    });
    viewer.scene.backgroundColor = Cesium.Color.BLACK;
    viewer.scene.screenSpaceCameraController.enableTilt = false;
    viewer.scene.skyBox.show = false;
    viewer.scene.skyAtmosphere.show = false;

    let nodes = {};
    let nodeData = [];
    let latCol = null;
    let lonCol = null;
    let colorColumn = null;
    let colorCache = {};

    function parseRobustFloat(str) {
      if (typeof str !== 'string') return NaN;
      const parsed = parseFloat(str.replace(',', '.'));
      return isNaN(parsed) ? NaN : parsed;
    }

    function parseCSV(content) {
      const rows = content.trim().split("\n");
      if (rows.length === 0) return [];
      
      const headers = rows.shift().split(",").map(h => h.trim().toLowerCase());
      
      // Eliminar filas completamente vacías
      const filteredRows = rows.filter(row => row.trim() !== '');

      return filteredRows.map(row => {
          const rowObject = {};
          const cells = row.split(",");
          headers.forEach((header, i) => {
              rowObject[header] = cells[i];
          });
          return rowObject;
      });
    }
    
    function getQuantileColors(data, column) {
      if (colorCache[column]) {
        return colorCache[column];
      }
      
      const values = data.map(node => parseRobustFloat(node[column])).filter(v => isFinite(v));
      if (values.length === 0) {
        return data.map(() => Cesium.Color.GRAY);
      }
      
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      
      const colors = data.map(node => {
        const value = parseRobustFloat(node[column]);
        if (!isFinite(value)) return Cesium.Color.GRAY;
        
        let t = 0.5; // Default for neutral
        if (value > 0) {
            if (maxVal === 0) return Cesium.Color.WHITE;
            t = (value - 0) / (maxVal - 0);
            return Cesium.Color.lerp(Cesium.Color.WHITE, Cesium.Color.RED, t, new Cesium.Color());
        } else if (value < 0) {
            if (minVal === 0) return Cesium.Color.WHITE;
            t = Math.abs(value - 0) / Math.abs(minVal - 0);
            return Cesium.Color.lerp(Cesium.Color.WHITE, Cesium.Color.BLUE, t, new Cesium.Color());
        } else {
            return Cesium.Color.WHITE;
        }
      });
      
      colorCache[column] = colors;
      return colors;
    }

    // === GEOJSON ===
    document.getElementById("geojsonFile").addEventListener("change", function (event) {
      const files = event.target.files;
      if (!files.length) return;

      Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            let geojson = JSON.parse(e.target.result);
            Cesium.GeoJsonDataSource.load(geojson, {
              stroke: Cesium.Color.CYAN,
              fill: Cesium.Color.fromAlpha(Cesium.Color.CYAN, 0.1),
              strokeWidth: 1.5,
              clampToGround: false
            }).then(dataSource => {
              viewer.dataSources.add(dataSource);
              viewer.zoomTo(dataSource);
            }).catch(err => {
              alert(`Error al cargar ${file.name}: ${err}`);
            });
          } catch (err) {
            alert(`Archivo inválido ${file.name}: ${err}`);
          }
        };
        reader.readAsText(file);
      });
    });

    // === NODOS ===
    document.getElementById("nodesFile").addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (event) {
        nodeData = parseCSV(event.target.result);
        if (nodeData.length === 0) {
            alert("No se pudieron leer los datos del archivo CSV. Asegúrate de que el formato sea correcto y no esté vacío.");
            return;
        }
        
        const headers = Object.keys(nodeData[0]);

        // Detectar automáticamente las columnas de latitud y longitud
        latCol = headers.find(h => h.includes("latitud") || h.includes("lat"));
        lonCol = headers.find(h => h.includes("longitud") || h.includes("lon"));
        
        if (!latCol || !lonCol) {
            alert("El archivo CSV debe contener una columna para latitud (ej: 'lat', 'latitud') y otra para longitud (ej: 'lon', 'longitud').");
            return;
        }

        const selectColor = document.getElementById("colorColumnSelect");
        selectColor.innerHTML = '';
        
        headers.forEach(h => {
          const option = document.createElement("option");
          option.value = h;
          option.text = h;
          selectColor.appendChild(option);
        });
        
        colorColumn = headers.find(h => h.includes("prom")) || headers[2] || headers[0];
        selectColor.value = colorColumn;
        
        // Configurar el deslizador de filtro
        const values = nodeData.map(node => parseRobustFloat(node[colorColumn])).filter(v => isFinite(v));
        const maxAbsVal = values.length > 0 ? Math.max(...values.map(v => Math.abs(v))) : 1;
        
        const slider = document.getElementById("valueFilterSlider");
        slider.min = 0;
        slider.max = maxAbsVal;
        slider.value = 0; // Inicialmente muestra todos los puntos
        document.getElementById("filterValueDisplay").innerText = "0";

        colorCache = {};
        renderNodes();
      };
      reader.readAsText(file);
    });

    function renderNodes() {
      viewer.entities.removeAll();
      nodes = {};
      
      const filterValue = parseFloat(document.getElementById("valueFilterSlider").value);
      const colors = getQuantileColors(nodeData, colorColumn);

      nodeData.forEach((node, index) => {
        const value = parseRobustFloat(node[colorColumn]);
        
        // Aplicar el filtro: solo renderizar si el valor absoluto está por encima del umbral
        if (isFinite(value) && Math.abs(value) < filterValue) {
            return; 
        }

        const lat = parseRobustFloat(node[latCol]);
        const lon = parseRobustFloat(node[lonCol]);
        
        if (isNaN(lat) || isNaN(lon)) {
          console.error(`Skipping row ${index}: Invalid lat/lon -> lat: ${node[latCol]}, lon: ${node[lonCol]}`);
          return;
        }
        
        nodes[`node_${index}`] = { lat, lon };

        viewer.entities.add({
          id: `node_${index}`,
          name: `node_${index}`,
          position: Cesium.Cartesian3.fromDegrees(lon, lat),
          point: {
            pixelSize: 8,
            color: colors[index]
          },
          properties: {
            value: value
          }
        });
      });
      
      if (Object.keys(nodes).length > 0) {
        viewer.zoomTo(viewer.entities);
      }
    }

    // === MANEJAR CAMBIOS EN LAS SELECCIONES ===
    document.getElementById("colorColumnSelect").addEventListener("change", function () {
      colorColumn = this.value;
      colorCache = {};
      renderNodes();
    });

    // === MANEJAR CAMBIOS EN EL DESLIZADOR ===
    document.getElementById("valueFilterSlider").addEventListener("input", function() {
        document.getElementById("filterValueDisplay").innerText = parseFloat(this.value).toFixed(6);
        renderNodes();
    });


    // === TOOLTIP ===
    const tooltip = document.getElementById("tooltip");
    viewer.screenSpaceEventHandler.setInputAction(function (movement) {
      const picked = viewer.scene.pick(movement.endPosition);
      if (Cesium.defined(picked) && picked.id && picked.id.properties) {
        const props = picked.id.properties;
        const value = props.value?.getValue() || "(sin valor)";

        tooltip.innerHTML = `<strong>Valor:</strong> ${value.toFixed(2)}`;
        tooltip.style.left = movement.endPosition.x + 10 + "px";
        tooltip.style.top = movement.endPosition.y + 10 + "px";
        tooltip.style.display = "block";
      } else {
        tooltip.style.display = "none";
      }
    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

    // === ARISTAS ===
    document.getElementById("edgesFile").addEventListener("change", function (e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (event) {
        const edges = parseCSV(event.target.result);
        edges.forEach(edge => {
          const from = nodes[edge.source];
          const to = nodes[edge.target];
          if (from && to) {
            viewer.entities.add({
              polyline: {
                positions: Cesium.Cartesian3.fromDegreesArray([
                  from.lon, from.lat,
                  to.lon, to.lat
                ]),
                width: 2,
                material: Cesium.Color.CYAN
              }
            });
          }
        });
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
